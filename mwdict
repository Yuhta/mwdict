#!/usr/bin/env ruby

require 'fileutils'
require 'net/http'
require 'optparse'
require 'rexml/document'

require 'launchy'
require 'term/ansicolor'

require 'pp'

class MwDict
  DEFAULT_OPTIONS = { color: true, strict: true }

  def initialize(ref, word, options = {})
    @ref, @word, @options = ref, word, DEFAULT_OPTIONS.merge(options)
  end

  def entry_list
    EntryList.new(xml.root, @options)
  end

  def xml
    path = local_path
    if @options[:no_cache]
      REXML::Document.new(Net::HTTP.get remote_uri)
    elsif File.exist? path
      open(path) { |f| REXML::Document.new f.read }
    else
      str   = Net::HTTP.get remote_uri
      doc   = REXML::Document.new str
      found = doc.root.elements.any? { |e| e.local_name != 'suggestion' }
      open(path, 'w') { |f| f.write str } if found
      doc
    end
  end

  def remote_uri
    key_env = "MWDICT_API_KEY_#{@ref.upcase}"
    key = ENV[key_env] || raise("#{key_env} undefined")
    root = "http://www.dictionaryapi.com/api/v1/references"
    URI "#{root}/#{@ref}/xml/#{URI.escape @word}?key=#{key}"
  end

  def local_path
    xdg    = ENV['XDG_CACHE_HOME'] || File.join(ENV['HOME'], '.cache')
    mwdict = ENV['MWDICT_CACHE_HOME'] || File.join(xdg, 'mwdict')
    dir    = File.join(mwdict, @ref.to_s)
    FileUtils.mkdir_p dir unless Dir.exist? dir
    File.join(dir, "#{@word}.xml")
  end

  def browse
    uri = case @ref
          when :learners
            "http://www.learnersdictionary.com/definition/#{@word}"
          else
            raise ArgumentError, "unknown reference: #{@ref}"
          end
    Launchy.open uri
  end

  private

  module WithOptions
    def unknown_element(e)
      if @options[:strict]
        raise "unknown element: #{e}"
      else
        e
      end
    end

    CENTERED_DOT = "\u00B7"
    EM_DASH      = "\u2014"
    DIAMOND      = "\u25CA"

    # Asterisks to centered dots
    def a2cd(s)
      s.gsub(/\*/, CENTERED_DOT)
    end

    # Superscript
    def sup(k)
      case k
      when Integer
        case k
        when 0    then "\u2070"
        when 1    then "\u00B9"
        when 2, 3 then [(0x00B0 + k)].pack('U')
        when 4..9 then [(0x2070 + k)].pack('U')
        else sup(k.to_s)
        end
      when String
        raise(ArgumentError, k) unless k =~ /\A[[:digit:]]+\z/
        r = ''
        k.each_char { |c| r << sup(c.to_i) }
        r
      else
        sup k.to_s
      end
    end

    def bold(s)
      @options[:color] ? Term::ANSIColor::bold { s } : s
    end

    def italic(s)
      @options[:color] ? Term::ANSIColor::italic { s } : s
    end

    def underline(s)
      @options[:color] ? Term::ANSIColor::underline { s } : s
    end

    def parse(e)
      e.map do |x|
        case x
        when REXML::Text    then x
        when REXML::Element then yield x
        else raise ArgumentError, "unknown child: #{x}"
        end
      end
    end

    def parse_markup(e)
      parse(e) do |x|
        case x.local_name
        when 'it'     then italic(x.text)
        when 'phrase' then bold(x.text)
        when 'sc'     then x.text.upcase
        else if block_given?
               yield x
             else
               unknown_element x
             end
        end
      end
    end
  end

  class EntryList
    def initialize(element, options)
      @entries     = []
      @suggestions = []
      element.elements.each do |e|
        case e.local_name
        when 'entry'      then @entries << Entry.new(e, options)
        when 'suggestion' then @suggestions << e.text
        else unknown_element e
        end
      end
      unless @entries.empty? || @suggestions.empty?
        raise 'cannot have both entries and suggestions'
      end
    end

    def to_s
      if !@suggestions.empty?
        ['The word you have entered is not in the dictionary.',
         'Use a spelling suggestion below or try your search again.',
         '',
         @suggestions.map { |s| ' ' * 4 + s }].join("\n")
      else
        @entries.join("\n\f\n")
      end
    end
  end

  class Entry
    include WithOptions

    def initialize(entry, options)
      @options = options
      @ins = []
      enum = entry.elements.to_enum
      loop do
        e = enum.next
        case e.local_name
        when 'hw'
          hw = HeadWord.new(e.text,
                            e.attributes['highlight'],
                            e.attributes['hindex'],
                            options)
          hsl = nil
          pr  = nil
          loop do
            ee = enum.peek
            case ee.local_name
            when 'hsl'         then hsl = ee.text
            when 'pr', 'altpr' then pr  = Pronunciation.new(ee, options)
            when 'sound' # Ignored
            else break
            end
            enum.next
          end
          @hw = HeadWordGroup.new(hw, hsl, pr, options)
        when 'fl'
          @fl = e.text
        when 'in'
          @ins << Inflection.new(e, options)
        when 'def'
          @def = Definition.new(e, options)
        when 'art'
          # Ignored
        else
          unknown_element e
        end
      end
    end

    def to_s
      s = @hw.to_s
      s << " #{italic @fl}"        if @fl
      s << "\n" << @ins.join('; ') unless @ins.empty?
      s << "\n#{@def}"             if @def
      s
    end
  end

  class HeadWordGroup
    include WithOptions

    def initialize(hw, hsl, pr, options)
      @options, @hw, @hsl, @pr = options, hw, hsl, pr
    end

    def to_s
      s = @hw.to_s
      s << " #{italic(@hsl)}" unless @hsl.nil?
      s << " #{@pr}"          unless @pr.nil?
      s
    end
  end

  class HeadWord
    include WithOptions

    def initialize(text, highlight, hindex, options)
      @options = options
      @text, @highlight, @hindex = text, highlight, hindex
    end

    def to_s
      s = bold(a2cd(@text))
      s = underline(s)     if @highlight == "yes"
      s = sup(@hindex) + s if @hindex
      s
    end
  end

  class Pronunciation
    include WithOptions

    def initialize(pr, options)
      @options = options
      @contents = parse_markup(pr)
    end

    def to_s
      "/#{@contents.join}/"
    end
  end

  class Inflection
    include WithOptions

    def initialize(inf, options)
      @options = options
      @contents = inf.elements.flat_map do |e|
        case e.local_name
        when 'il'          then italic(e.text)
        when 'if'          then bold(a2cd(e.text))
        when 'pr', 'altpr' then Pronunciation.new(e)
        when 'sound'       then []
        else unknown_element e
        end
      end
    end

    def to_s
      @contents.join ' '
    end
  end

  class Definition
    include WithOptions

    def initialize(defi, options)
      @options  = options
      @sls      = []
      @senses   = []
      before_dt = []
      enum = defi.elements.to_enum
      loop do
        e = enum.next
        case e.local_name
        when 'gram'
          @gram = e.text
        when 'sl'
          @sls << e.text
        when 'sn'
          before_dt << bold(e.text)
        # TODO
        else
          unknown_element e
        end
      end
    end
  end
end

def parse_argv!
  options = { ref: :learners }

  parser = OptionParser.new do |parser|
    parser.banner << ' word'
    parser.separator "\nOptions:"

    parser.on_tail '-h', '--help', 'Show this message and exit' do
      puts parser
      exit
    end

    parser.on '-b', '--browser', 'Search the word in the default browser' do
      options[:browser] = true
    end

    parser.on '--no-cache', 'Do not use cache' do
      options[:no_cache] = true
    end

    parser.on '--no-color', 'Do not output ANSI color escape code' do
      options[:color] = false
    end

    parser.on '--non-strict', 'Do not raise error in many cases' do
      options[:strict] = false
    end

    parser.on('-r', '--reference REFERENCE',
              'Reference to use, default to learners') do |ref|
      options[:ref] = ref.downcase.to_sym
    end
  end

  parser.parse!

  if ARGV.empty?
    puts parser.banner
    raise ArgumentError, 'no word specified'
  end
  options[:word] = ARGV.shift.strip.downcase

  options
end

if __FILE__ == $PROGRAM_NAME
  options = parse_argv!
  mwdict = MwDict.new(options[:ref], options[:word], options)
  if options[:browser]
    mwdict.browse
  else
    puts mwdict.entry_list
  end
end
